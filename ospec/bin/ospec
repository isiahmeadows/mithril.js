#!/usr/bin/env node
/* eslint-disable global-require */
"use strict"

process.on("unhandledRejection", function(e) {
	throw e
	// console.error("Uncaught (in promise) " + e.stack)
})

var path = require("path")
var glob = require("glob")
var argv = ["--globs"].concat(process.argv.slice(2))
var args = {}
var name
argv.forEach(function(arg) {
	if (arg === "--module") return
	if ((/^--/).test(arg)) {
		name = arg.substr(2)
		args[name] = args[name] || []
	} else {
		args[name].push(arg)
	}
})

var globList = args.globs && args.globs.length ? args.globs : ["**/tests/**/*.js"]
var ignore = ["**/node_modules/**"].concat(args.ignore || [])

// Hack: hijack Node's internal resolution algorithm to require the file as if
// from a fake module in the correct base directory. It also will avoid several
// bugs with the `resolve` module (Node's is necessarily more stable).
var dirname = path.resolve(process.cwd())
var m = new module.constructor(path.join(dirname, "dummy.js"))
m.filename = m.id
m.paths = module.constructor._nodeModulePaths(dirname)
m.loaded = true

if (args.require) {
	args.require.forEach(function (name) { if (name) m.require(name) })
}

var remaining = globList.length

globList.forEach(function(globPattern) {
	glob(globPattern, {ignore: ignore})
		.on("match", function(name) { m.require(path.join(dirname, name)) })
		.on("error", function(e) { console.error(e) })
		.on("end", function() {
			if (remaining === 0) return
			if (--remaining !== 0) return
			m.require("ospec").run()
		})
})
